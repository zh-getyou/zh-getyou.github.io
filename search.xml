<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[xml]]></title>
    <url>%2F2019%2F08%2F21%2Fxml%2F</url>
    <content type="text"><![CDATA[12341. XML 1. 概念 2. 语法 3. 解析 XML：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631. 概念：Extensible Markup Language 可扩展标记语言 * 可扩展：标签都是自定义的。 &lt;user&gt; &lt;student&gt; * 功能 * 存储数据 1. 配置文件 2. 在网络中传输 * xml与html的区别 1. xml标签都是自定义的，html标签是预定义。 2. xml的语法严格，html语法松散 3. xml是存储数据的，html是展示数据 * w3c:万维网联盟2. 语法： * 基本语法： 1. xml文档的后缀名 .xml 2. xml第一行必须定义为文档声明 3. xml文档中有且仅有一个根标签 4. 属性值必须使用引号(单双都可)引起来 5. 标签必须正确关闭 6. xml标签名称区分大小写 * 快速入门： &lt;?xml version=&apos;1.0&apos; ?&gt; &lt;users&gt; &lt;user id=&apos;1&apos;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id=&apos;2&apos;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; * 组成部分： 1. 文档声明 1. 格式：&lt;?xml 属性列表 ?&gt; 2. 属性列表： * version：版本号，必须的属性 * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 * standalone：是否独立 * 取值： * yes：不依赖其他文件 * no：依赖其他文件 2. 指令(了解)：结合css的 * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; 3. 标签：标签名称自定义的 * 规则： * 名称可以包含字母、数字以及其他的字符 * 名称不能以数字或者标点符号开始 * 名称不能以字母 xml（或者 XML、Xml 等等）开始 * 名称不能包含空格 4. 属性： id属性值唯一 5. 文本： * CDATA区：在该区域中的数据会被原样展示 * 格式： &lt;![CDATA[ 数据 ]]&gt; ​​ * 约束：规定xml文档的书写规则​ * 作为框架的使用者(程序员)：​ 1. 能够在xml中引入约束文档​ 2. 能够简单的读懂约束文档​ 123* 分类： 1. DTD:一种简单的约束技术 2. Schema:一种复杂的约束技术 123456* DTD： * 引入dtd文档到xml文档中 * 内部dtd：将约束规则定义在xml文档中 * 外部dtd：将约束的规则定义在外部的dtd文件中 * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; 12345678910* Schema: * 引入： 1.填写xml文档的根元素 2.引入xsi前缀. xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 3.引入xsd文件命名空间. xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 4.为每一个xsd约束声明一个前缀,作为标识 xmlns=&quot;http://www.itcast.cn/xml&quot; &lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; ​ 1234567891011123. 解析：操作xml文档，将文档中的数据读取到内存中 * 操作xml文档 1. 解析(读取)：将文档中的数据读取到内存中 2. 写入：将内存中的数据保存到xml文档中。持久化的存储 * 解析xml的方式： 1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 * 优点：操作方便，可以对文档进行CRUD的所有操作 * 缺点：占内存 2. SAX：逐行读取，基于事件驱动的。 * 优点：不占内存。 * 缺点：只能读取，不能增删改 ​​ * xml常见的解析器：​ 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想​ 2. DOM4J：一款非常优秀的解析器​ 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。​ 4. PULL：Android操作系统内置的解析器，sax方式的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950* Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 * 快速入门： * 步骤： 1. 导入jar包 2. 获取Document对象 3. 获取对应的标签Element对象 4. 获取数据 * 代码： //2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.获取元素对象 Element Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name);* 对象的使用： 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse​(File in, String charsetName)：解析xml或html文件的。 * parse​(String html)：解析xml或html字符串 * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 2. Document：文档对象。代表内存中的dom树 * 获取Element对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用 4. Element：元素对象 1. 获取子元素对象 * getElementById​(String id)：根据id属性值获取唯一的element对象 * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合 * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合 * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合 2. 获取属性值 * String attr(String key)：根据属性名称获取属性值 3. 获取文本内容 * String text():获取文本内容 * String html():获取标签体的所有内容(包括字标签的字符串内容) 5. Node：节点对象 * 是Document和Element的父类 ​​ * 快捷查询方式：​ 1. selector:选择器​ * 使用的方法：Elements select​(String cssQuery)​ * 语法：参考Selector类中定义的语法​ 2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言​ * 使用Jsoup的Xpath需要额外导入jar包。​ * 查询w3cshool参考手册，使用xpath的语法完成查询​ * 代码：​ //1.获取student.xml的path​ String path = JsoupDemo6.class.getClassLoader().getResource(“student.xml”).getPath();​ //2.获取Document对象​ Document document = Jsoup.parse(new File(path), “utf-8”);​ 1234567891011121314151617181920212223242526272829303132//3.根据document对象，创建JXDocument对象JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询//4.1查询所有student标签List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode);&#125; System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode);&#125;System.out.println(&quot;--------------------&quot;);//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode);&#125;]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Junit单元测试&反射&注解]]></title>
    <url>%2F2019%2F08%2F10%2FJunit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%8F%8D%E5%B0%84-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. Junit单元测试 2. 反射 3. 注解Junit单元测试：* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。 * Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行反射：框架设计的灵魂* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 * 反射：将类的各个组成部分封装为其他对象，这就是反射机制 * 好处： 1. 可以在程序运行过程中，操作这些对象。 2. 可以解耦，提高程序的可扩展性。 * 获取Class对象的方式： 1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 * Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() * Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 * Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 * Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名 * 案例： * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 * 实现： 1. 配置文件 2. 反射 * 步骤： 1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2. 在程序中加载读取配置文件 3. 使用反射技术来加载类文件进内存 4. 创建对象 5. 执行方法注解：* 概念：说明程序的。给计算机看的 * 注释：用文字描述程序的。给程序员看的 * 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 * 概念描述： * JDK1.5之后的新特性 * 说明程序的 * 使用注解：@注解名称 * 作用分类： ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 * JDK中预定义的一些注解 * @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 * @Deprecated：该注解标注的内容，表示已过时 * @SuppressWarnings：压制警告 * 一般传递参数all @SuppressWarnings(&quot;all&quot;) * 自定义注解 * 格式： 元注解 public @interface 注解名称{ 属性列表; } * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 * public interface MyAnno extends java.lang.annotation.Annotation {} * 属性：接口中的抽象方法 * 要求： 1. 属性的返回值类型有下列取值 * 基本数据类型 * String * 枚举 * 注解 * 以上类型的数组 2. 定义了属性，在使用时需要给属性赋值 1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 * 元注解：用于描述注解的注解 * @Target：描述注解能够作用的位置 * ElementType取值： * TYPE：可以作用于类上 * METHOD：可以作用于方法上 * FIELD：可以作用于成员变量上 * @Retention：描述注解被保留的阶段 * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 * @Documented：描述注解是否被抽取到api文档中 * @Inherited：描述注解是否被子类继承 * 在程序使用(解析)注解：获取注解中定义的属性值 1. 获取注解定义的位置的对象 （Class，Method,Field） 2. 获取指定的注解 * getAnnotation(Class) //其实就是在内存中生成了一个该注解接口的子类实现对象 public class ProImpl implements Pro{ public String className(){ return &quot;cn.itcast.annotation.Demo1&quot;; } public String methodName(){ return &quot;show&quot;; } } 3. 调用注解中的抽象方法获取配置的属性值 * 案例：简单的测试框架 * 小结： 1. 以后大多数时候，我们会使用注解，而不是自定义注解 2. 注解给谁用？ 1. 编译器 2. 给解析程序用 3. 注解不是程序的一部分，可以理解为注解就是一个标签]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown的使用]]></title>
    <url>%2F2019%2F07%2F19%2FMarkdown%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题 列表1 列表2 a 子列表 b 子列表 列表3 CSDN导航 设置字体为斜体设置字体为加粗&lt;html&gt;&lt;/html&gt; //插入单行代码 123456789&lt;!DOCTYPE html&gt; //插入多行代码&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;这是一个非常好的网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是我的第一个网页&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 引用内容]]></content>
      <categories>
        <category>说明</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
